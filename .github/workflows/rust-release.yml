name: Rust Build & Release

on:
  workflow_call:
    inputs:
      binary-name:
        description: 'Binary name (defaults to repository name)'
        required: false
        type: string
        default: ''
      exclude:
        description: 'Comma-separated platforms to exclude'
        required: false
        type: string
        default: ''
      rust-version:
        description: 'Rust version to use'
        required: false
        type: string
        default: 'stable'
      cargo-args:
        description: 'Additional cargo build arguments'
        required: false
        type: string
        default: '--release'
      release-tag:
        description: 'Release tag to create'
        required: true
        type: string
      generate-checksums:
        description: 'Generate SHA256 checksums'
        required: false
        type: boolean
        default: true
      create-archives:
        description: 'Create tar.gz/zip archives'
        required: false
        type: boolean
        default: true
      # npm publishing options
      enable-npm:
        description: 'Enable npm publishing'
        required: false
        type: boolean
        default: false
      npm-package-name:
        description: 'npm package name (required if enable-npm=true)'
        required: false
        type: string
        default: ''
      npm-dist-tag:
        description: 'npm dist-tag (latest, beta, alpha, rc, dev)'
        required: false
        type: string
        default: 'latest'
      npm-description:
        description: 'Package description'
        required: false
        type: string
        default: ''
    secrets:
      GITHUB_TOKEN:
        required: true
      NPM_TOKEN:
        required: false

env:
  CARGO_TERM_COLOR: always
  # Default platform matrix - simple hardcoded list
  PLATFORMS: '[
    {"target": "x86_64-unknown-linux-gnu", "os": "ubuntu-latest", "platform": "linux-x86_64"},
    {"target": "aarch64-unknown-linux-gnu", "os": "ubuntu-latest", "platform": "linux-arm64"},
    {"target": "x86_64-unknown-linux-musl", "os": "ubuntu-latest", "platform": "linux-x86_64-musl"},
    {"target": "aarch64-unknown-linux-musl", "os": "ubuntu-latest", "platform": "linux-arm64-musl"},
    {"target": "x86_64-apple-darwin", "os": "macos-12", "platform": "mac-x86_64"},
    {"target": "aarch64-apple-darwin", "os": "macos-latest", "platform": "mac-arm64"},
    {"target": "x86_64-pc-windows-msvc", "os": "windows-latest", "platform": "windows-x86_64"},
    {"target": "aarch64-pc-windows-msvc", "os": "windows-latest", "platform": "windows-arm64"}
  ]'

jobs:
  build:
    name: Build (${{ matrix.platform }})
    runs-on: ${{ matrix.os }}
    outputs:
      binary-name: ${{ steps.setup.outputs.binary-name }}
      filtered-platforms: ${{ steps.filter-platforms.outputs.platforms }}
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(steps.filter-platforms.outputs.platforms) }}
    
    steps:
      - name: Filter platforms
        id: filter-platforms
        shell: bash
        run: |
          PLATFORMS='${{ env.PLATFORMS }}'
          EXCLUDE_INPUT="${{ inputs.exclude }}"
          
          if [[ -z "$EXCLUDE_INPUT" ]]; then
            echo "platforms=$PLATFORMS" >> $GITHUB_OUTPUT
          else
            # Simple filtering using jq
            EXCLUDE_FILTER=""
            IFS=',' read -ra EXCLUDE_ARRAY <<< "$EXCLUDE_INPUT"
            for exclude_platform in "${EXCLUDE_ARRAY[@]}"; do
              exclude_platform=$(echo "$exclude_platform" | xargs)
              if [[ -n "$EXCLUDE_FILTER" ]]; then
                EXCLUDE_FILTER="$EXCLUDE_FILTER and "
              fi
              EXCLUDE_FILTER="$EXCLUDE_FILTER.platform != \"$exclude_platform\""
            done
            
            FILTERED_PLATFORMS=$(echo "$PLATFORMS" | jq "[.[] | select($EXCLUDE_FILTER)]")
            echo "platforms=$FILTERED_PLATFORMS" >> $GITHUB_OUTPUT
          fi

      - name: Setup
        id: setup
        shell: bash
        run: |
          # Set binary name (auto-detect from repo if not provided)
          BINARY_NAME="${{ inputs.binary-name }}"
          if [[ -z "$BINARY_NAME" ]]; then
            BINARY_NAME="${{ github.event.repository.name }}"
          fi
          
          echo "binary-name=$BINARY_NAME" >> $GITHUB_OUTPUT
          echo "Building binary: $BINARY_NAME for ${{ matrix.platform }}"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ inputs.rust-version }}
          targets: ${{ matrix.target }}

      - name: Setup cross-compilation
        if: runner.os == 'Linux'
        shell: bash
        run: |
          case "${{ matrix.target }}" in
            aarch64-unknown-linux-gnu)
              sudo apt-get update && sudo apt-get install -y gcc-aarch64-linux-gnu
              echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV
              ;;
            x86_64-unknown-linux-musl)
              sudo apt-get update && sudo apt-get install -y musl-tools
              ;;
            aarch64-unknown-linux-musl)
              sudo apt-get update && sudo apt-get install -y musl-tools gcc-aarch64-linux-gnu
              echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV
              ;;
          esac

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-${{ matrix.target }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.target }}-cargo-

      - name: Build binary
        shell: bash
        run: |
          BINARY_NAME="${{ steps.setup.outputs.binary-name }}"
          
          # Build binary (let cargo handle validation and errors)
          cargo build --bin "$BINARY_NAME" --target ${{ matrix.target }} ${{ inputs.cargo-args }}
          
          # Determine binary extension
          BINARY_EXT=""
          if [[ "${{ matrix.target }}" == *"windows"* ]]; then
            BINARY_EXT=".exe"
          fi
          
          # Copy to release directory
          mkdir -p release
          SOURCE="target/${{ matrix.target }}/release/${BINARY_NAME}${BINARY_EXT}"
          TARGET="release/${BINARY_NAME}-${{ matrix.platform }}${BINARY_EXT}"
          
          cp "$SOURCE" "$TARGET"
          
          # Set executable permissions (Unix)
          if [[ "${{ matrix.target }}" != *"windows"* ]]; then
            chmod +x "$TARGET"
          fi
          
          echo "Built: $TARGET"

      - name: Create archive
        if: inputs.create-archives
        shell: bash
        run: |
          BINARY_NAME="${{ steps.setup.outputs.binary-name }}"
          PLATFORM="${{ matrix.platform }}"
          TAG="${{ inputs.release-tag }}"
          
          # Determine file extensions
          BINARY_EXT=""
          ARCHIVE_EXT="tar.gz"
          if [[ "${{ matrix.target }}" == *"windows"* ]]; then
            BINARY_EXT=".exe"
            ARCHIVE_EXT="zip"
          fi
          
          BINARY_FILE="${BINARY_NAME}-${PLATFORM}${BINARY_EXT}"
          ARCHIVE_NAME="${BINARY_NAME}-${TAG}-${PLATFORM}"
          
          # Create archive with binary
          mkdir -p "temp/$ARCHIVE_NAME"
          cp "release/$BINARY_FILE" "temp/$ARCHIVE_NAME/"
          
          cd temp
          if [[ "$ARCHIVE_EXT" == "zip" ]]; then
            zip -r "../release/${ARCHIVE_NAME}.zip" "$ARCHIVE_NAME"
          else
            tar -czf "../release/${ARCHIVE_NAME}.tar.gz" "$ARCHIVE_NAME"
          fi
          cd ..
          rm -rf temp
          
          echo "Created: ${ARCHIVE_NAME}.${ARCHIVE_EXT}"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: binaries-${{ matrix.platform }}
          path: release/
          retention-days: 1

  release:
    name: Create GitHub Release
    needs: build
    runs-on: ubuntu-latest
    outputs:
      release-id: ${{ steps.create-release.outputs.id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release assets
        shell: bash
        run: |
          mkdir -p release-assets
          find artifacts -type f -exec cp {} release-assets/ \;
          
          echo "Release assets:"
          ls -la release-assets/

      - name: Generate checksums
        if: inputs.generate-checksums
        shell: bash
        run: |
          cd release-assets
          
          if command -v sha256sum >/dev/null; then
            sha256sum * > checksums.txt
          else
            shasum -a 256 * > checksums.txt
          fi
          
          echo "Generated checksums:"
          cat checksums.txt

      - name: Create GitHub Release
        id: create-release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ inputs.release-tag }}
          name: Release ${{ inputs.release-tag }}
          files: release-assets/*
          generate_release_notes: true
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  npm-publish:
    name: Publish to npm
    if: inputs.enable-npm
    needs: [build, release]
    runs-on: ubuntu-latest
    steps:
      - name: Validate npm inputs
        shell: bash
        run: |
          if [[ -z "${{ inputs.npm-package-name }}" ]]; then
            echo "Error: npm-package-name is required when enable-npm=true"
            exit 1
          fi
          
          if [[ -z "${{ secrets.NPM_TOKEN }}" ]]; then
            echo "Error: NPM_TOKEN secret is required for npm publishing"
            exit 1
          fi

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          registry-url: 'https://registry.npmjs.org'

      - name: Download release assets
        shell: bash
        run: |
          # Download binaries from GitHub release
          gh release download ${{ inputs.release-tag }} --dir binaries
          
          echo "Downloaded binaries:"
          ls -la binaries/
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create npm package
        shell: bash
        run: |
          BINARY_NAME="${{ needs.build.outputs.binary-name }}"
          PACKAGE_NAME="${{ inputs.npm-package-name }}"
          VERSION="${{ inputs.release-tag }}"
          
          # Remove 'v' prefix from version if present
          VERSION=${VERSION#v}
          
          # Create package structure
          mkdir -p npm-package/bin
          
          # Copy binaries and create wrapper scripts
          for platform in linux-x86_64 linux-arm64 mac-x86_64 mac-arm64 windows-x86_64; do
            if [[ "$platform" == "windows-x86_64" ]]; then
              BINARY_FILE="${BINARY_NAME}-${platform}.exe"
              if [[ -f "binaries/$BINARY_FILE" ]]; then
                cp "binaries/$BINARY_FILE" "npm-package/bin/"
              fi
            else
              BINARY_FILE="${BINARY_NAME}-${platform}"
              if [[ -f "binaries/$BINARY_FILE" ]]; then
                cp "binaries/$BINARY_FILE" "npm-package/bin/"
              fi
            fi
          done
          
          # Create wrapper script
          cat > npm-package/bin/${PACKAGE_NAME} << 'EOF'
          #!/usr/bin/env node
          const { spawn } = require('child_process');
          const path = require('path');
          const os = require('os');
          
          function getBinaryName() {
            const platform = os.platform();
            const arch = os.arch();
            
            let platformName;
            if (platform === 'linux') {
              platformName = arch === 'arm64' ? 'linux-arm64' : 'linux-x86_64';
            } else if (platform === 'darwin') {
              platformName = arch === 'arm64' ? 'mac-arm64' : 'mac-x86_64';
            } else if (platform === 'win32') {
              platformName = 'windows-x86_64';
              return `BINARY_NAME-${platformName}.exe`;
            } else {
              throw new Error(`Unsupported platform: ${platform}`);
            }
            
            return `BINARY_NAME-${platformName}`;
          }
          
          const binaryName = getBinaryName();
          const binaryPath = path.join(__dirname, binaryName);
          
          const child = spawn(binaryPath, process.argv.slice(2), { stdio: 'inherit' });
          child.on('exit', (code) => process.exit(code));
          EOF
          
          # Replace placeholder in wrapper
          sed -i.bak "s/BINARY_NAME/${BINARY_NAME}/g" npm-package/bin/${PACKAGE_NAME}
          rm npm-package/bin/${PACKAGE_NAME}.bak
          
          chmod +x npm-package/bin/${PACKAGE_NAME}
          
          # Create package.json
          cat > npm-package/package.json << EOF
          {
            "name": "${PACKAGE_NAME}",
            "version": "${VERSION}",
            "description": "${{ inputs.npm-description || format('Command line tool for {0}', needs.build.outputs.binary-name) }}",
            "bin": {
              "${PACKAGE_NAME}": "./bin/${PACKAGE_NAME}"
            },
            "files": ["bin/"],
            "keywords": ["cli", "tool", "rust", "binary"],
            "author": "${{ github.repository_owner }}",
            "license": "MIT",
            "homepage": "${{ github.server_url }}/${{ github.repository }}",
            "repository": {
              "type": "git",
              "url": "${{ github.server_url }}/${{ github.repository }}.git"
            },
            "bugs": {
              "url": "${{ github.server_url }}/${{ github.repository }}/issues"
            }
          }
          EOF

      - name: Publish to npm
        shell: bash
        run: |
          cd npm-package
          
          # Publish with specified dist-tag
          npm publish --tag ${{ inputs.npm-dist-tag }}
          
          echo "Published ${{ inputs.npm-package-name }}@$(cat package.json | jq -r .version) with tag: ${{ inputs.npm-dist-tag }}"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}